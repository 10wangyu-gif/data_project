---
name: 部署配置优化
status: open
created: 2025-09-16T08:20:41Z
updated: 2025-09-16T08:20:41Z
github: [Will be updated when synced to GitHub]
depends_on: [001, 002, 003, 004, 005, 006, 007, 008]
parallel: false
---

# Task 009: 部署配置优化

## 概述
针对信创环境进行国产化兼容性优化，实施性能调优和安全加固，确保系统在生产环境中稳定高效运行。

## 国产化兼容性

### 1. 操作系统适配
```yaml
# deploy/os-compatibility/kylin.yml
# 麒麟系统部署配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: kylin-system-config
data:
  system.conf: |
    # 麒麟系统特有配置
    OS_TYPE=Kylin
    KERNEL_VERSION=4.19.90

    # 资源限制调整
    MAX_MEMORY=8Gi
    MAX_CPU=4

    # 网络配置
    NETWORK_MODE=bridge
    DNS_SERVERS=114.114.114.114,8.8.8.8

    # 存储配置
    STORAGE_DRIVER=overlay2
    DATA_ROOT=/opt/env-platform/data

  limits.conf: |
    # 系统资源限制
    * soft nofile 65536
    * hard nofile 65536
    * soft nproc 32768
    * hard nproc 32768
    root soft nofile 65536
    root hard nofile 65536
```

```bash
# scripts/install-kylin.sh
#!/bin/bash
# 麒麟系统安装脚本

set -e

echo "检测系统版本..."
if ! grep -q "Kylin" /etc/os-release; then
    echo "警告: 未检测到麒麟系统"
    read -p "是否继续安装? (y/N): " confirm
    [[ $confirm != [yY] ]] && exit 1
fi

echo "配置系统环境..."
# 设置时区
timedatectl set-timezone Asia/Shanghai

# 配置yum源 (使用国产镜像)
cat > /etc/yum.repos.d/kylin.repo << 'EOF'
[kylin-base]
name=Kylin Base Repository
baseurl=http://archive.kylinos.cn/kylin/KYLIN-ALL/
enabled=1
gpgcheck=0

[docker-ce-stable]
name=Docker CE Stable
baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/
enabled=1
gpgcheck=0
EOF

# 安装必要软件
yum update -y
yum install -y \
    docker-ce \
    docker-compose \
    nginx \
    firewalld \
    chrony \
    rsyslog

# 配置Docker镜像加速
mkdir -p /etc/docker
cat > /etc/docker/daemon.json << 'EOF'
{
  "registry-mirrors": [
    "https://registry.cn-hangzhou.aliyuncs.com",
    "https://docker.mirrors.ustc.edu.cn"
  ],
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "100m",
    "max-file": "3"
  },
  "storage-driver": "overlay2"
}
EOF

systemctl enable docker
systemctl start docker

echo "麒麟系统环境配置完成"
```

### 2. 国产数据库集成
```go
// pkg/database/domestic.go
package database

import (
    "database/sql"
    "fmt"

    _ "github.com/godror/godror"          // 达梦数据库驱动
    _ "github.com/lib/pq"                 // 人大金仓驱动
    _ "gitee.com/opengauss/openGauss-connector-go-pq" // openGauss驱动
)

type DomesticDBConfig struct {
    Type     string `yaml:"type"`     // dameng, kingbase, opengauss
    Host     string `yaml:"host"`
    Port     int    `yaml:"port"`
    Database string `yaml:"database"`
    Username string `yaml:"username"`
    Password string `yaml:"password"`
    Options  map[string]string `yaml:"options"`
}

func NewDomesticDB(config DomesticDBConfig) (*sql.DB, error) {
    var dsn string

    switch config.Type {
    case "dameng":
        // 达梦数据库连接
        dsn = fmt.Sprintf("dm://%s:%s@%s:%d/%s",
            config.Username, config.Password,
            config.Host, config.Port, config.Database)

    case "kingbase":
        // 人大金仓连接
        dsn = fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",
            config.Host, config.Port, config.Username, config.Password, config.Database)

    case "opengauss":
        // openGauss连接
        dsn = fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",
            config.Host, config.Port, config.Username, config.Password, config.Database)

    default:
        return nil, fmt.Errorf("不支持的数据库类型: %s", config.Type)
    }

    db, err := sql.Open(config.Type, dsn)
    if err != nil {
        return nil, fmt.Errorf("连接数据库失败: %v", err)
    }

    // 连接池配置
    db.SetMaxOpenConns(25)
    db.SetMaxIdleConns(10)
    db.SetConnMaxLifetime(300)

    if err := db.Ping(); err != nil {
        return nil, fmt.Errorf("数据库连接测试失败: %v", err)
    }

    return db, nil
}

// 数据库迁移适配
func MigrateToDomesticDB(sourceDB, targetDB *sql.DB, dbType string) error {
    migrator := &DomesticDBMigrator{
        Source: sourceDB,
        Target: targetDB,
        Type:   dbType,
    }

    return migrator.Migrate()
}
```

### 3. 信创中间件适配
```yaml
# deploy/middleware/xinchang.yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: env-platform-xinchang
spec:
  replicas: 3
  selector:
    matchLabels:
      app: env-platform
  template:
    metadata:
      labels:
        app: env-platform
    spec:
      containers:
      - name: app
        image: registry.cn-hangzhou.aliyuncs.com/xinchang/env-platform:latest
        env:
        - name: MIDDLEWARE_TYPE
          value: "xinchang"
        - name: MESSAGE_QUEUE
          value: "rabbitmq-xinchang"  # 东方通TongLINK/Q
        - name: CACHE_PROVIDER
          value: "redis-xinchang"     # 达梦Redis兼容版
        - name: WEB_SERVER
          value: "tongweb"            # 东方通TongWeb
        ports:
        - containerPort: 8080
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        volumeMounts:
        - name: xinchang-config
          mountPath: /etc/xinchang
      volumes:
      - name: xinchang-config
        configMap:
          name: xinchang-middleware-config
```

## 性能优化

### 1. 数据库性能调优
```sql
-- scripts/db-optimization.sql
-- 数据库性能优化脚本

-- 索引优化
CREATE INDEX CONCURRENTLY idx_sensor_data_time_sensor
ON sensor_data (measurement_time, sensor_id)
WHERE measurement_time >= NOW() - INTERVAL '30 days';

CREATE INDEX CONCURRENTLY idx_alerts_created_status
ON alerts (created_at, status)
WHERE status IN ('active', 'acknowledged');

-- 分区表优化 (PostgreSQL/人大金仓)
CREATE TABLE sensor_data_partitioned (
    LIKE sensor_data INCLUDING ALL
) PARTITION BY RANGE (measurement_time);

-- 创建月度分区
CREATE TABLE sensor_data_2025_01 PARTITION OF sensor_data_partitioned
FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

-- 查询优化视图
CREATE MATERIALIZED VIEW sensor_stats_hourly AS
SELECT
    sensor_id,
    DATE_TRUNC('hour', measurement_time) as hour,
    AVG(value) as avg_value,
    MIN(value) as min_value,
    MAX(value) as max_value,
    COUNT(*) as measurement_count
FROM sensor_data
WHERE measurement_time >= NOW() - INTERVAL '7 days'
GROUP BY sensor_id, DATE_TRUNC('hour', measurement_time);

-- 创建刷新定时任务
CREATE OR REPLACE FUNCTION refresh_sensor_stats()
RETURNS void AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY sensor_stats_hourly;
END;
$$ LANGUAGE plpgsql;

-- 设置定时刷新
SELECT cron.schedule('refresh-sensor-stats', '0 * * * *', 'SELECT refresh_sensor_stats();');
```

### 2. 应用层优化
```go
// pkg/optimization/cache.go
package optimization

import (
    "context"
    "encoding/json"
    "time"

    "github.com/go-redis/redis/v8"
    "github.com/golang/groupcache"
)

type CacheManager struct {
    redis      *redis.Client
    localCache *groupcache.Group
}

func NewCacheManager(redisClient *redis.Client) *CacheManager {
    // 本地缓存配置
    localCache := groupcache.NewGroup("env-platform", 64<<20, groupcache.GetterFunc(
        func(ctx context.Context, key string, dest groupcache.Sink) error {
            // 从数据库获取数据
            data, err := fetchFromDatabase(key)
            if err != nil {
                return err
            }
            dest.SetBytes(data)
            return nil
        },
    ))

    return &CacheManager{
        redis:      redisClient,
        localCache: localCache,
    }
}

// 多级缓存策略
func (cm *CacheManager) Get(ctx context.Context, key string) ([]byte, error) {
    // L1: 本地缓存
    var data []byte
    err := cm.localCache.Get(ctx, key, groupcache.AllocatingByteSliceSink(&data))
    if err == nil {
        return data, nil
    }

    // L2: Redis缓存
    result, err := cm.redis.Get(ctx, key).Result()
    if err == nil {
        return []byte(result), nil
    }

    // L3: 数据库查询
    dbData, err := fetchFromDatabase(key)
    if err != nil {
        return nil, err
    }

    // 写入缓存
    go func() {
        cm.redis.Set(ctx, key, dbData, time.Hour).Err()
    }()

    return dbData, nil
}

// 批量预热缓存
func (cm *CacheManager) WarmupCache(ctx context.Context) error {
    // 预热热点数据
    hotKeys := []string{
        "sensors:active",
        "alerts:current",
        "stats:realtime",
    }

    for _, key := range hotKeys {
        go func(k string) {
            cm.Get(ctx, k)
        }(key)
    }

    return nil
}
```

### 3. 网络优化
```nginx
# deploy/nginx/nginx.conf
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log;
pid /run/nginx.pid;

events {
    worker_connections 4096;
    use epoll;
    multi_accept on;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # 日志格式优化
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                   '$status $body_bytes_sent "$http_referer" '
                   '"$http_user_agent" $request_time $upstream_response_time';

    access_log /var/log/nginx/access.log main;

    # 性能优化
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    client_max_body_size 100M;

    # Gzip压缩
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/javascript
        application/json
        application/xml+rss;

    # 缓存配置
    proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=api_cache:10m
                     max_size=1g inactive=60m use_temp_path=off;

    upstream env_platform_backend {
        least_conn;
        server app1:8080 max_fails=3 fail_timeout=30s;
        server app2:8080 max_fails=3 fail_timeout=30s;
        server app3:8080 max_fails=3 fail_timeout=30s;
        keepalive 32;
    }

    server {
        listen 80;
        listen 443 ssl http2;
        server_name env-platform.local;

        # SSL配置
        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;

        # 静态资源缓存
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
            add_header Vary Accept-Encoding;
        }

        # API代理
        location /api/ {
            proxy_pass http://env_platform_backend;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_cache_bypass $http_upgrade;

            # 缓存配置
            proxy_cache api_cache;
            proxy_cache_valid 200 5m;
            proxy_cache_valid 404 1m;
            proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
        }

        # WebSocket代理
        location /ws/ {
            proxy_pass http://env_platform_backend;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "Upgrade";
            proxy_set_header Host $host;
            proxy_read_timeout 86400;
        }
    }
}
```

## 安全加固

### 1. 容器安全
```dockerfile
# deploy/security/Dockerfile.secure
FROM alpine:3.18 AS builder

# 使用非root用户构建
RUN addgroup -g 1001 appgroup && \
    adduser -u 1001 -G appgroup -s /bin/sh -D appuser

WORKDIR /app
COPY --chown=appuser:appgroup . .

# 构建应用
RUN apk add --no-cache go git && \
    go mod download && \
    CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .

# 生产镜像
FROM scratch

# 复制CA证书
COPY --from=alpine:3.18 /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/

# 复制用户信息
COPY --from=builder /etc/passwd /etc/passwd
COPY --from=builder /etc/group /etc/group

# 复制应用
COPY --from=builder --chown=1001:1001 /app/main /app/main
COPY --from=builder --chown=1001:1001 /app/configs /app/configs

USER 1001

EXPOSE 8080

ENTRYPOINT ["/app/main"]
```

### 2. 网络安全
```yaml
# deploy/security/network-policy.yml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: env-platform-network-policy
spec:
  podSelector:
    matchLabels:
      app: env-platform
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: env-platform
    - podSelector:
        matchLabels:
          app: nginx-ingress
    ports:
    - protocol: TCP
      port: 8080
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          name: env-platform
    ports:
    - protocol: TCP
      port: 5432  # PostgreSQL
    - protocol: TCP
      port: 6379  # Redis
  - to: []
    ports:
    - protocol: TCP
      port: 53   # DNS
    - protocol: UDP
      port: 53   # DNS
```

### 3. 数据加密
```go
// pkg/security/encryption.go
package security

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "crypto/sha256"
    "encoding/base64"
    "fmt"
    "io"
)

type DataEncryption struct {
    key []byte
    gcm cipher.AEAD
}

func NewDataEncryption(password string) (*DataEncryption, error) {
    // 生成加密密钥
    hash := sha256.Sum256([]byte(password))
    key := hash[:]

    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, err
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }

    return &DataEncryption{
        key: key,
        gcm: gcm,
    }, nil
}

// 加密敏感数据
func (de *DataEncryption) Encrypt(plaintext string) (string, error) {
    nonce := make([]byte, de.gcm.NonceSize())
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        return "", err
    }

    ciphertext := de.gcm.Seal(nonce, nonce, []byte(plaintext), nil)
    return base64.StdEncoding.EncodeToString(ciphertext), nil
}

// 解密敏感数据
func (de *DataEncryption) Decrypt(ciphertext string) (string, error) {
    data, err := base64.StdEncoding.DecodeString(ciphertext)
    if err != nil {
        return "", err
    }

    nonceSize := de.gcm.NonceSize()
    if len(data) < nonceSize {
        return "", fmt.Errorf("密文长度不足")
    }

    nonce, ciphertext := data[:nonceSize], data[nonceSize:]
    plaintext, err := de.gcm.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        return "", err
    }

    return string(plaintext), nil
}

// 数据脱敏
func MaskSensitiveData(data string, dataType string) string {
    switch dataType {
    case "phone":
        if len(data) >= 11 {
            return data[:3] + "****" + data[7:]
        }
    case "email":
        parts := strings.Split(data, "@")
        if len(parts) == 2 {
            return parts[0][:1] + "***@" + parts[1]
        }
    case "id_card":
        if len(data) >= 18 {
            return data[:6] + "********" + data[14:]
        }
    }
    return data
}
```

## 监控和运维

### 1. 健康检查
```go
// pkg/health/checker.go
package health

import (
    "context"
    "database/sql"
    "fmt"
    "net/http"
    "time"
)

type HealthChecker struct {
    db    *sql.DB
    redis *redis.Client
}

type HealthStatus struct {
    Status    string            `json:"status"`
    Timestamp time.Time         `json:"timestamp"`
    Checks    map[string]Check  `json:"checks"`
}

type Check struct {
    Status  string        `json:"status"`
    Message string        `json:"message,omitempty"`
    Latency time.Duration `json:"latency"`
}

func (hc *HealthChecker) CheckHealth(ctx context.Context) *HealthStatus {
    status := &HealthStatus{
        Timestamp: time.Now(),
        Checks:    make(map[string]Check),
    }

    // 检查数据库
    dbCheck := hc.checkDatabase(ctx)
    status.Checks["database"] = dbCheck

    // 检查Redis
    redisCheck := hc.checkRedis(ctx)
    status.Checks["redis"] = redisCheck

    // 检查磁盘空间
    diskCheck := hc.checkDiskSpace()
    status.Checks["disk"] = diskCheck

    // 检查内存使用
    memCheck := hc.checkMemory()
    status.Checks["memory"] = memCheck

    // 总体状态
    status.Status = "healthy"
    for _, check := range status.Checks {
        if check.Status != "healthy" {
            status.Status = "unhealthy"
            break
        }
    }

    return status
}

func (hc *HealthChecker) checkDatabase(ctx context.Context) Check {
    start := time.Now()
    err := hc.db.PingContext(ctx)
    latency := time.Since(start)

    if err != nil {
        return Check{
            Status:  "unhealthy",
            Message: fmt.Sprintf("数据库连接失败: %v", err),
            Latency: latency,
        }
    }

    return Check{
        Status:  "healthy",
        Latency: latency,
    }
}
```

### 2. 自动化部署
```yaml
# deploy/automation/deploy.yml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: env-platform
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://git.company.com/env-platform.git
    targetRevision: HEAD
    path: deploy/k8s
  destination:
    server: https://kubernetes.default.svc
    namespace: env-platform
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
    - CreateNamespace=true
    retry:
      limit: 5
      backoff:
        duration: 5s
        factor: 2
        maxDuration: 3m
```

## 实施计划

### 第1天: 国产化兼容性适配
- [ ] 操作系统兼容性测试和配置
- [ ] 国产数据库驱动集成
- [ ] 信创中间件适配

### 第2天: 性能优化实施
- [ ] 数据库查询优化
- [ ] 应用层缓存优化
- [ ] 网络配置调优

### 第3天: 安全加固
- [ ] 容器安全配置
- [ ] 网络安全策略
- [ ] 数据加密实现

### 第4天: 监控运维
- [ ] 健康检查系统
- [ ] 自动化部署配置
- [ ] 运维脚本编写

### 第5天: 综合测试优化
- [ ] 性能压力测试
- [ ] 安全渗透测试
- [ ] 兼容性验证

## 交付物
- [ ] 国产化兼容性配置
- [ ] 性能优化配置和脚本
- [ ] 安全加固策略和实现
- [ ] 运维监控系统

## 验收标准
- 支持主流信创环境部署
- 系统性能提升30%以上
- 通过安全等级保护三级测评
- 监控覆盖率达到95%以上