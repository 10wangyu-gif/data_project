---
name: 数据源管理模块
status: open
created: 2025-09-16T08:20:41Z
updated: 2025-09-16T08:20:41Z
github: [Will be updated when synced to GitHub]
depends_on: [001]
parallel: true
conflicts_with: []
---

# Task 003: 数据源管理模块

## 概述
实现环保数据平台的数据源管理核心功能，重点支持HJ212环保数据传输协议，同时提供数据源连接配置、实时状态监控和数据采集管理。这是平台数据采集的基础模块，具有较高的技术复杂度。

## 技术要求
- **协议支持**: HJ212-2017环保数据传输标准协议
- **网络通信**: TCP/UDP Socket编程，Netty NIO框架
- **数据解析**: 自定义HJ212报文解析器
- **任务调度**: Spring Task Scheduler / Quartz
- **监控告警**: 实时连接状态监控和异常告警

## 验收标准

### 1. HJ212协议支持
- [ ] 实现HJ212-2017标准协议解析
  - 心跳包处理(HeartBeat)
  - 数据包处理(Data)
  - 应答包处理(Response)
  - 上传时间包处理(RequestInfo)
  - 上传参数包处理(SetParam/GetParam)
- [ ] 支持多种数据传输方式
  - TCP长连接
  - UDP数据包
  - HTTP POST方式
- [ ] 实现数据包验证和错误处理
  - CRC校验
  - 报文格式验证
  - 异常数据处理

### 2. 数据源连接管理
- [ ] 数据源配置管理
  - 连接参数配置(IP、端口、协议类型)
  - 认证信息管理(设备ID、密码)
  - 采集频率和策略配置
- [ ] 连接池管理
  - TCP连接池优化
  - 连接复用和释放
  - 连接超时处理
- [ ] 动态配置更新
  - 运行时配置修改
  - 配置变更热更新
  - 配置版本管理

### 3. 实时状态监控
- [ ] 连接状态监控
  - 实时连接状态显示
  - 连接质量评估
  - 网络延迟监控
- [ ] 数据采集监控
  - 数据接收统计
  - 数据质量分析
  - 异常数据报告
- [ ] 设备状态监控
  - 设备在线状态
  - 设备健康状况
  - 设备运行参数

### 4. 数据采集和存储
- [ ] 实时数据采集
  - 多线程并发采集
  - 数据缓冲和批量处理
  - 数据去重和校验
- [ ] 数据预处理
  - 数据格式标准化
  - 数据质量标记
  - 异常数据过滤
- [ ] 数据存储优化
  - 分区表存储策略
  - 数据压缩算法
  - 历史数据归档

## 技术实现细节

### HJ212协议解析器
```java
@Component
public class HJ212ProtocolParser {

    // HJ212数据包结构: ##数据段长度ST=设备唯一标识号;CN=命令编号;PW=访问密码;MN=设备唯一标识号;CP=&&数据区&&CRC校验;
    private static final Pattern HJ212_PATTERN = Pattern.compile(
        "##(\\d{4})ST=(\\d+);CN=(\\d+);PW=([^;]*);MN=([^;]*);CP=&&(.*)&&([A-F0-9]{4})"
    );

    public HJ212Message parseMessage(String message) {
        Matcher matcher = HJ212_PATTERN.matcher(message);
        if (!matcher.matches()) {
            throw new HJ212ParseException("Invalid HJ212 message format");
        }

        HJ212Message hj212Message = new HJ212Message();
        hj212Message.setDataLength(Integer.parseInt(matcher.group(1)));
        hj212Message.setSystemTime(Long.parseLong(matcher.group(2)));
        hj212Message.setCommandNumber(matcher.group(3));
        hj212Message.setPassword(matcher.group(4));
        hj212Message.setDeviceId(matcher.group(5));
        hj212Message.setDataArea(matcher.group(6));
        hj212Message.setCrc(matcher.group(7));

        // 验证CRC校验码
        if (!validateCRC(message, hj212Message.getCrc())) {
            throw new HJ212ParseException("CRC validation failed");
        }

        // 解析数据区
        parseDataArea(hj212Message);
        return hj212Message;
    }

    private void parseDataArea(HJ212Message message) {
        String dataArea = message.getDataArea();
        Map<String, Object> dataMap = new HashMap<>();

        // 解析监测数据 QN=时间戳;DataTime=数据时间;
        String[] pairs = dataArea.split(";");
        for (String pair : pairs) {
            String[] keyValue = pair.split("=", 2);
            if (keyValue.length == 2) {
                dataMap.put(keyValue[0], keyValue[1]);
            }
        }

        message.setParsedData(dataMap);
    }
}
```

### Netty服务器实现
```java
@Component
public class HJ212Server {

    @Value("${hj212.server.port:8080}")
    private int serverPort;

    private EventLoopGroup bossGroup;
    private EventLoopGroup workerGroup;
    private Channel serverChannel;

    @Autowired
    private HJ212MessageHandler messageHandler;

    @PostConstruct
    public void startServer() throws InterruptedException {
        bossGroup = new NioEventLoopGroup(1);
        workerGroup = new NioEventLoopGroup();

        try {
            ServerBootstrap bootstrap = new ServerBootstrap();
            bootstrap.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .option(ChannelOption.SO_BACKLOG, 1024)
                    .childOption(ChannelOption.SO_KEEPALIVE, true)
                    .childHandler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        protected void initChannel(SocketChannel ch) {
                            ChannelPipeline pipeline = ch.pipeline();

                            // 添加编解码器
                            pipeline.addLast(new DelimiterBasedFrameDecoder(8192,
                                Delimiters.lineDelimiter()));
                            pipeline.addLast(new StringDecoder(CharsetUtil.UTF_8));
                            pipeline.addLast(new StringEncoder(CharsetUtil.UTF_8));

                            // 添加业务处理器
                            pipeline.addLast(new HJ212ServerHandler(messageHandler));
                        }
                    });

            ChannelFuture future = bootstrap.bind(serverPort).sync();
            serverChannel = future.channel();

            log.info("HJ212 Server started on port {}", serverPort);
        } catch (Exception e) {
            shutdown();
            throw e;
        }
    }

    @PreDestroy
    public void shutdown() {
        if (serverChannel != null) {
            serverChannel.close();
        }
        if (workerGroup != null) {
            workerGroup.shutdownGracefully();
        }
        if (bossGroup != null) {
            bossGroup.shutdownGracefully();
        }
    }
}
```

### 数据源实体和配置
```java
@Entity
@Table(name = "data_sources")
public class DataSource {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Enumerated(EnumType.STRING)
    private DataSourceType type; // HJ212_TCP, HJ212_UDP, HTTP, FTP

    @Column(columnDefinition = "jsonb")
    @Type(JsonType.class)
    private DataSourceConfig connectionConfig;

    @Enumerated(EnumType.STRING)
    private DataSourceStatus status; // ACTIVE, INACTIVE, ERROR

    @Column(name = "last_connection_time")
    private LocalDateTime lastConnectionTime;

    @Column(name = "last_data_time")
    private LocalDateTime lastDataTime;

    @Column(name = "error_count")
    private Integer errorCount = 0;

    // getters and setters
}

@Data
public class DataSourceConfig {
    private String host;
    private Integer port;
    private String protocol; // TCP, UDP
    private String deviceId;
    private String password;
    private Integer heartbeatInterval; // 心跳间隔(秒)
    private Integer dataTimeout; // 数据超时(秒)
    private Boolean enableRetry;
    private Integer maxRetryCount;
    private Map<String, Object> extendedConfig;
}
```

### 数据采集服务
```java
@Service
@Slf4j
public class DataCollectionService {

    @Autowired
    private DataSourceRepository dataSourceRepository;

    @Autowired
    private EnvironmentalDataRepository dataRepository;

    @Autowired
    private HJ212ProtocolParser protocolParser;

    // 连接管理器映射
    private final Map<Long, DataSourceConnection> connectionMap = new ConcurrentHashMap<>();

    @Scheduled(fixedRate = 30000) // 每30秒检查一次
    public void monitorDataSources() {
        List<DataSource> activeSources = dataSourceRepository.findByStatus(DataSourceStatus.ACTIVE);

        for (DataSource source : activeSources) {
            DataSourceConnection connection = connectionMap.get(source.getId());

            if (connection == null || !connection.isConnected()) {
                connectToDataSource(source);
            } else {
                // 检查连接健康状况
                checkConnectionHealth(source, connection);
            }
        }
    }

    private void connectToDataSource(DataSource source) {
        try {
            DataSourceConnection connection = createConnection(source);
            connection.connect();
            connectionMap.put(source.getId(), connection);

            // 更新连接状态
            source.setLastConnectionTime(LocalDateTime.now());
            source.setErrorCount(0);
            dataSourceRepository.save(source);

            log.info("Successfully connected to data source: {}", source.getName());
        } catch (Exception e) {
            handleConnectionError(source, e);
        }
    }

    public void processHJ212Message(String deviceId, String rawMessage) {
        try {
            HJ212Message message = protocolParser.parseMessage(rawMessage);

            // 查找对应的数据源
            DataSource source = dataSourceRepository.findByDeviceId(deviceId)
                .orElseThrow(() -> new DataSourceNotFoundException("Device not found: " + deviceId));

            // 解析监测数据
            Map<String, Object> parsedData = message.getParsedData();
            String dataTime = (String) parsedData.get("DataTime");

            // 保存环境数据
            for (Map.Entry<String, Object> entry : parsedData.entrySet()) {
                if (isPollutantData(entry.getKey())) {
                    EnvironmentalData data = new EnvironmentalData();
                    data.setDataSourceId(source.getId());
                    data.setDataTime(parseDataTime(dataTime));
                    data.setPollutantCode(entry.getKey());
                    data.setValue(new BigDecimal(entry.getValue().toString()));
                    data.setRawData(rawMessage);

                    dataRepository.save(data);
                }
            }

            // 更新数据源最后数据时间
            source.setLastDataTime(LocalDateTime.now());
            dataSourceRepository.save(source);

        } catch (Exception e) {
            log.error("Error processing HJ212 message from device {}: {}", deviceId, e.getMessage(), e);
        }
    }
}
```

### 监控状态API
```java
@RestController
@RequestMapping("/api/data-sources")
public class DataSourceController {

    @Autowired
    private DataSourceService dataSourceService;

    @GetMapping("/{id}/status")
    public ResponseEntity<DataSourceStatus> getDataSourceStatus(@PathVariable Long id) {
        DataSourceStatusInfo status = dataSourceService.getDetailedStatus(id);
        return ResponseEntity.ok(status);
    }

    @GetMapping("/{id}/metrics")
    public ResponseEntity<DataSourceMetrics> getDataSourceMetrics(
            @PathVariable Long id,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime from,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime to) {

        DataSourceMetrics metrics = dataSourceService.getMetrics(id, from, to);
        return ResponseEntity.ok(metrics);
    }

    @PostMapping("/{id}/test-connection")
    public ResponseEntity<ConnectionTestResult> testConnection(@PathVariable Long id) {
        ConnectionTestResult result = dataSourceService.testConnection(id);
        return ResponseEntity.ok(result);
    }
}
```

## 数据库表设计

### 监测点表
```sql
CREATE TABLE monitoring_points (
    id BIGSERIAL PRIMARY KEY,
    data_source_id BIGINT REFERENCES data_sources(id),
    point_code VARCHAR(50) NOT NULL,
    point_name VARCHAR(100),
    location POINT, -- PostGIS地理坐标
    elevation DECIMAL(10,2),
    point_type VARCHAR(50), -- 废水、废气、噪声等
    status INTEGER DEFAULT 1,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 数据源连接日志
CREATE TABLE data_source_logs (
    id BIGSERIAL PRIMARY KEY,
    data_source_id BIGINT REFERENCES data_sources(id),
    event_type VARCHAR(20), -- CONNECT, DISCONNECT, ERROR, DATA_RECEIVED
    event_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    message TEXT,
    details JSONB
);

-- 数据质量记录
CREATE TABLE data_quality_records (
    id BIGSERIAL PRIMARY KEY,
    data_source_id BIGINT REFERENCES data_sources(id),
    check_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    total_records BIGINT,
    valid_records BIGINT,
    invalid_records BIGINT,
    quality_score DECIMAL(5,2),
    issues JSONB
);
```

## Definition of Done
- [ ] HJ212-2017协议完整实现，支持所有标准包类型
- [ ] TCP/UDP服务器稳定运行，支持并发连接
- [ ] 数据源配置管理界面完成，支持动态配置
- [ ] 实时状态监控功能实现，包含连接状态和数据质量
- [ ] 数据采集和存储功能稳定，数据完整性保证
- [ ] 异常处理和容错机制完善，系统稳定性验证
- [ ] 性能测试通过：支持100+并发连接，数据处理延迟<500ms
- [ ] 监控告警功能实现，及时发现连接和数据异常
- [ ] API接口完整，支持数据源管理和状态查询
- [ ] 技术文档完成，包含HJ212协议说明和部署指南

## 风险和依赖
- **技术风险**: HJ212协议复杂度高，需要深入理解环保行业标准
- **性能风险**: 大量并发连接和实时数据处理对系统性能要求高
- **兼容性风险**: 不同厂商设备的HJ212实现可能存在差异
- **依赖**: 依赖Task 001的数据库表结构和基础架构

## 验证方式
- 使用HJ212标准测试数据验证协议解析正确性
- 模拟多个设备并发连接测试系统稳定性
- 长时间运行测试验证内存泄漏和性能稳定性
- 网络异常模拟测试验证容错机制
- 数据完整性检查确保无数据丢失