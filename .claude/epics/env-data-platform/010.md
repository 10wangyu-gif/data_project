---
name: 测试验收交付
status: open
created: 2025-09-16T08:20:41Z
updated: 2025-09-16T08:20:41Z
github: [Will be updated when synced to GitHub]
depends_on: [009]
parallel: false
---

# Task 010: 测试验收交付

## 概述
实施全面的系统测试、性能验证和用户培训，确保环境数据平台满足生产要求并顺利交付使用。

## 功能测试

### 1. 自动化测试套件
```go
// tests/integration/platform_test.go
package integration

import (
    "context"
    "testing"
    "time"

    "github.com/stretchr/testify/suite"
    "github.com/testcontainers/testcontainers-go"
    "github.com/testcontainers/testcontainers-go/modules/postgres"
)

type PlatformTestSuite struct {
    suite.Suite
    ctx        context.Context
    db         *sql.DB
    redis      *redis.Client
    httpClient *http.Client
    containers []testcontainers.Container
}

func (suite *PlatformTestSuite) SetupSuite() {
    suite.ctx = context.Background()

    // 启动测试数据库
    dbContainer, err := postgres.RunContainer(suite.ctx,
        testcontainers.WithImage("postgres:13"),
        postgres.WithDatabase("env_platform_test"),
        postgres.WithUsername("test"),
        postgres.WithPassword("test"),
    )
    suite.Require().NoError(err)
    suite.containers = append(suite.containers, dbContainer)

    // 连接数据库
    connStr, err := dbContainer.ConnectionString(suite.ctx)
    suite.Require().NoError(err)

    suite.db, err = sql.Open("postgres", connStr)
    suite.Require().NoError(err)

    // 运行数据库迁移
    suite.runMigrations()

    // 启动应用服务
    suite.startServices()
}

// 测试传感器数据采集流程
func (suite *PlatformTestSuite) TestSensorDataCollection() {
    // 1. 创建传感器
    sensor := CreateSensorRequest{
        Name:     "测试传感器",
        Type:     "air_quality",
        Location: "测试地点",
        Config: SensorConfig{
            Interval: 60,
            Metrics:  []string{"pm25", "temperature", "humidity"},
        },
    }

    resp := suite.createSensor(sensor)
    suite.Equal(201, resp.StatusCode)

    var createdSensor SensorResponse
    suite.decodeJSON(resp.Body, &createdSensor)
    sensorID := createdSensor.ID

    // 2. 模拟数据上报
    dataPoints := []DataPoint{
        {
            SensorID:  sensorID,
            Metric:    "pm25",
            Value:     35.5,
            Timestamp: time.Now(),
        },
        {
            SensorID:  sensorID,
            Metric:    "temperature",
            Value:     25.8,
            Timestamp: time.Now(),
        },
    }

    for _, dp := range dataPoints {
        resp := suite.uploadData(dp)
        suite.Equal(201, resp.StatusCode)
    }

    // 3. 验证数据存储
    time.Sleep(2 * time.Second) // 等待异步处理

    storedData := suite.queryDataBySensor(sensorID)
    suite.Len(storedData, 2)
    suite.Equal(35.5, storedData[0].Value)
    suite.Equal(25.8, storedData[1].Value)

    // 4. 验证实时数据推送
    wsConn := suite.connectWebSocket("/ws/realtime")
    defer wsConn.Close()

    // 上报新数据
    newData := DataPoint{
        SensorID:  sensorID,
        Metric:    "humidity",
        Value:     65.2,
        Timestamp: time.Now(),
    }
    suite.uploadData(newData)

    // 验证WebSocket推送
    var wsMessage RealtimeMessage
    err := wsConn.ReadJSON(&wsMessage)
    suite.NoError(err)
    suite.Equal("data_update", wsMessage.Type)
    suite.Equal(sensorID, wsMessage.Data.SensorID)
}

// 测试告警系统
func (suite *PlatformTestSuite) TestAlertSystem() {
    // 1. 创建告警规则
    rule := AlertRule{
        Name:        "PM2.5超标告警",
        SensorType:  "air_quality",
        Metric:      "pm25",
        Condition:   "greater_than",
        Threshold:   75.0,
        Duration:    300, // 5分钟
        Severity:    "high",
        Enabled:     true,
    }

    resp := suite.createAlertRule(rule)
    suite.Equal(201, resp.StatusCode)

    // 2. 模拟触发告警的数据
    sensorID := suite.createTestSensor()
    triggerData := DataPoint{
        SensorID:  sensorID,
        Metric:    "pm25",
        Value:     85.3, // 超过阈值
        Timestamp: time.Now(),
    }

    suite.uploadData(triggerData)

    // 3. 验证告警生成
    time.Sleep(10 * time.Second) // 等待告警处理

    alerts := suite.queryActiveAlerts()
    suite.Greater(len(alerts), 0)

    triggeredAlert := suite.findAlertByRule(alerts, rule.Name)
    suite.NotNil(triggeredAlert)
    suite.Equal("active", triggeredAlert.Status)
    suite.Equal("high", triggeredAlert.Severity)

    // 4. 测试告警确认
    resp = suite.acknowledgeAlert(triggeredAlert.ID)
    suite.Equal(200, resp.StatusCode)

    // 验证状态更新
    updatedAlert := suite.getAlert(triggeredAlert.ID)
    suite.Equal("acknowledged", updatedAlert.Status)
}

// 测试数据分析功能
func (suite *PlatformTestSuite) TestDataAnalysis() {
    // 准备测试数据
    sensorID := suite.createTestSensor()
    suite.uploadTestData(sensorID, 100) // 上传100个数据点

    // 测试趋势分析
    analysisReq := AnalysisRequest{
        SensorIDs: []string{sensorID},
        Metrics:   []string{"pm25", "temperature"},
        StartTime: time.Now().Add(-24 * time.Hour),
        EndTime:   time.Now(),
        Type:      "trend",
    }

    resp := suite.requestAnalysis(analysisReq)
    suite.Equal(200, resp.StatusCode)

    var analysis AnalysisResponse
    suite.decodeJSON(resp.Body, &analysis)

    suite.NotEmpty(analysis.Trends)
    suite.Greater(len(analysis.Trends["pm25"]), 0)

    // 测试预测分析
    analysisReq.Type = "prediction"
    analysisReq.PredictionHours = 24

    resp = suite.requestAnalysis(analysisReq)
    suite.Equal(200, resp.StatusCode)

    var prediction PredictionResponse
    suite.decodeJSON(resp.Body, &prediction)

    suite.NotEmpty(prediction.Predictions)
    suite.Greater(len(prediction.Predictions["pm25"]), 0)
}
```

### 2. API测试覆盖
```yaml
# tests/api/postman-collection.json
{
  "info": {
    "name": "环境数据平台API测试",
    "version": "1.0.0"
  },
  "item": [
    {
      "name": "认证测试",
      "item": [
        {
          "name": "用户登录",
          "request": {
            "method": "POST",
            "url": "{{baseUrl}}/api/v1/auth/login",
            "body": {
              "mode": "raw",
              "raw": "{\"username\":\"admin\",\"password\":\"password\"}"
            }
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('登录成功', function() {",
                  "    pm.response.to.have.status(200);",
                  "    const response = pm.response.json();",
                  "    pm.expect(response.token).to.not.be.empty;",
                  "    pm.globals.set('authToken', response.token);",
                  "});"
                ]
              }
            }
          ]
        }
      ]
    },
    {
      "name": "传感器管理",
      "item": [
        {
          "name": "创建传感器",
          "request": {
            "method": "POST",
            "url": "{{baseUrl}}/api/v1/sensors",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{authToken}}"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\"name\":\"测试传感器\",\"type\":\"air_quality\",\"location\":\"测试地点\"}"
            }
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('传感器创建成功', function() {",
                  "    pm.response.to.have.status(201);",
                  "    const response = pm.response.json();",
                  "    pm.expect(response.id).to.not.be.empty;",
                  "    pm.globals.set('sensorId', response.id);",
                  "});"
                ]
              }
            }
          ]
        }
      ]
    }
  ]
}
```

## 性能测试

### 1. 负载测试脚本
```python
# tests/performance/load_test.py
import asyncio
import aiohttp
import time
import json
from concurrent.futures import ThreadPoolExecutor
import websockets
import statistics

class PerformanceTest:
    def __init__(self, base_url, concurrent_users=100):
        self.base_url = base_url
        self.concurrent_users = concurrent_users
        self.results = []

    async def login_and_get_token(self):
        """获取认证令牌"""
        async with aiohttp.ClientSession() as session:
            async with session.post(
                f"{self.base_url}/api/v1/auth/login",
                json={"username": "admin", "password": "password"}
            ) as resp:
                data = await resp.json()
                return data.get("token")

    async def test_api_endpoint(self, session, token, endpoint, method="GET", data=None):
        """测试API端点性能"""
        headers = {"Authorization": f"Bearer {token}"}
        start_time = time.time()

        try:
            if method == "GET":
                async with session.get(f"{self.base_url}{endpoint}", headers=headers) as resp:
                    status = resp.status
                    await resp.text()
            elif method == "POST":
                async with session.post(f"{self.base_url}{endpoint}",
                                      headers=headers, json=data) as resp:
                    status = resp.status
                    await resp.text()

            response_time = (time.time() - start_time) * 1000  # ms
            return {"status": status, "response_time": response_time, "success": status < 400}

        except Exception as e:
            return {"status": 0, "response_time": 0, "success": False, "error": str(e)}

    async def simulate_data_upload(self, concurrent_uploads=50, duration_seconds=300):
        """模拟并发数据上传"""
        token = await self.login_and_get_token()

        async def upload_worker():
            async with aiohttp.ClientSession() as session:
                sensor_data = {
                    "sensor_id": "test-sensor-001",
                    "metric": "pm25",
                    "value": 45.6,
                    "timestamp": int(time.time())
                }

                return await self.test_api_endpoint(
                    session, token, "/api/v1/data", "POST", sensor_data
                )

        print(f"开始数据上传压力测试: {concurrent_uploads}并发, {duration_seconds}秒")

        start_time = time.time()
        results = []

        while time.time() - start_time < duration_seconds:
            tasks = [upload_worker() for _ in range(concurrent_uploads)]
            batch_results = await asyncio.gather(*tasks, return_exceptions=True)

            for result in batch_results:
                if not isinstance(result, Exception):
                    results.append(result)

            await asyncio.sleep(1)  # 每秒一批请求

        # 统计结果
        successful_requests = [r for r in results if r["success"]]
        failed_requests = [r for r in results if not r["success"]]
        response_times = [r["response_time"] for r in successful_requests]

        print(f"数据上传测试结果:")
        print(f"总请求数: {len(results)}")
        print(f"成功请求: {len(successful_requests)}")
        print(f"失败请求: {len(failed_requests)}")
        print(f"成功率: {len(successful_requests)/len(results)*100:.2f}%")

        if response_times:
            print(f"平均响应时间: {statistics.mean(response_times):.2f}ms")
            print(f"中位数响应时间: {statistics.median(response_times):.2f}ms")
            print(f"95%响应时间: {statistics.quantiles(response_times, n=20)[18]:.2f}ms")

        return results

    async def test_websocket_performance(self, concurrent_connections=100):
        """测试WebSocket连接性能"""
        print(f"开始WebSocket性能测试: {concurrent_connections}并发连接")

        async def websocket_worker():
            try:
                uri = f"ws://localhost:8080/ws/realtime"
                async with websockets.connect(uri) as websocket:
                    # 保持连接5分钟
                    await asyncio.sleep(300)
                    return {"success": True}
            except Exception as e:
                return {"success": False, "error": str(e)}

        tasks = [websocket_worker() for _ in range(concurrent_connections)]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        successful_connections = len([r for r in results if r.get("success", False)])
        print(f"WebSocket测试结果: {successful_connections}/{concurrent_connections} 连接成功")

        return results

    async def run_comprehensive_test(self):
        """运行综合性能测试"""
        print("开始综合性能测试...")

        # 1. API响应时间测试
        token = await self.login_and_get_token()
        test_endpoints = [
            "/api/v1/sensors",
            "/api/v1/data/realtime",
            "/api/v1/alerts",
            "/api/v1/analysis/dashboard"
        ]

        async with aiohttp.ClientSession() as session:
            for endpoint in test_endpoints:
                print(f"测试端点: {endpoint}")
                tasks = [self.test_api_endpoint(session, token, endpoint)
                        for _ in range(self.concurrent_users)]
                results = await asyncio.gather(*tasks)

                successful_results = [r for r in results if r["success"]]
                if successful_results:
                    avg_time = statistics.mean([r["response_time"] for r in successful_results])
                    print(f"  平均响应时间: {avg_time:.2f}ms")
                    print(f"  成功率: {len(successful_results)/len(results)*100:.2f}%")

        # 2. 数据上传压力测试
        await self.simulate_data_upload()

        # 3. WebSocket连接测试
        await self.test_websocket_performance()

# 运行测试
if __name__ == "__main__":
    test = PerformanceTest("http://localhost:8080", concurrent_users=100)
    asyncio.run(test.run_comprehensive_test())
```

### 2. 压力测试配置
```yaml
# tests/performance/k6-test.js
import http from 'k6/http';
import ws from 'k6/ws';
import { check, sleep } from 'k6';
import { Counter, Rate, Trend } from 'k6/metrics';

// 自定义指标
const errorRate = new Rate('error_rate');
const responseTime = new Trend('response_time');
const wsConnections = new Counter('ws_connections');

export let options = {
  stages: [
    { duration: '2m', target: 100 },   // 启动阶段
    { duration: '5m', target: 100 },   // 稳定阶段
    { duration: '2m', target: 200 },   // 增压阶段
    { duration: '5m', target: 200 },   // 高压阶段
    { duration: '2m', target: 0 },     // 降压阶段
  ],
  thresholds: {
    http_req_duration: ['p(95)<1000'],  // 95%请求在1秒内完成
    http_req_failed: ['rate<0.05'],     // 错误率低于5%
    error_rate: ['rate<0.05'],
  },
};

const BASE_URL = 'http://localhost:8080';
let authToken = '';

export function setup() {
  // 获取认证令牌
  const loginRes = http.post(`${BASE_URL}/api/v1/auth/login`,
    JSON.stringify({
      username: 'admin',
      password: 'password'
    }), {
      headers: { 'Content-Type': 'application/json' }
    }
  );

  if (loginRes.status === 200) {
    const body = JSON.parse(loginRes.body);
    authToken = body.token;
  }

  return { token: authToken };
}

export default function(data) {
  const headers = {
    'Authorization': `Bearer ${data.token}`,
    'Content-Type': 'application/json'
  };

  // 测试场景1: 查询传感器列表
  let response = http.get(`${BASE_URL}/api/v1/sensors`, { headers });
  check(response, {
    '传感器列表查询成功': (r) => r.status === 200,
    '响应时间合理': (r) => r.timings.duration < 1000,
  });
  errorRate.add(response.status !== 200);
  responseTime.add(response.timings.duration);

  sleep(1);

  // 测试场景2: 上传传感器数据
  const dataPayload = JSON.stringify({
    sensor_id: `sensor-${__VU}-${__ITER}`,
    metric: 'pm25',
    value: Math.random() * 100,
    timestamp: Date.now()
  });

  response = http.post(`${BASE_URL}/api/v1/data`, dataPayload, { headers });
  check(response, {
    '数据上传成功': (r) => r.status === 201,
  });
  errorRate.add(response.status !== 201);

  sleep(1);

  // 测试场景3: 查询实时数据
  response = http.get(`${BASE_URL}/api/v1/data/realtime`, { headers });
  check(response, {
    '实时数据查询成功': (r) => r.status === 200,
  });

  // 每10个用户中有1个测试WebSocket
  if (__VU % 10 === 0) {
    const wsUrl = 'ws://localhost:8080/ws/realtime';
    const wsResponse = ws.connect(wsUrl, {}, function(socket) {
      socket.on('open', function() {
        wsConnections.add(1);
        socket.send(JSON.stringify({ type: 'subscribe', data: 'realtime' }));
      });

      socket.on('message', function(data) {
        const message = JSON.parse(data);
        check(message, {
          'WebSocket消息格式正确': (m) => m.type !== undefined,
        });
      });

      socket.on('error', function(e) {
        console.log('WebSocket错误:', e.error());
      });

      // 保持连接30秒
      setTimeout(function() {
        socket.close();
      }, 30000);
    });
  }

  sleep(2);
}

export function teardown(data) {
  console.log('压力测试完成');
}
```

## 兼容性测试

### 1. 浏览器兼容性测试
```javascript
// tests/compatibility/browser-test.js
const { chromium, firefox, webkit } = require('playwright');

class BrowserCompatibilityTest {
  constructor() {
    this.browsers = ['chromium', 'firefox', 'webkit'];
    this.testResults = {};
  }

  async runTest() {
    for (const browserName of this.browsers) {
      console.log(`测试浏览器: ${browserName}`);

      const browser = await this.launchBrowser(browserName);
      const page = await browser.newPage();

      try {
        this.testResults[browserName] = await this.testBrowserFeatures(page);
      } catch (error) {
        this.testResults[browserName] = { error: error.message };
      } finally {
        await browser.close();
      }
    }

    this.generateCompatibilityReport();
  }

  async launchBrowser(browserName) {
    switch (browserName) {
      case 'chromium':
        return await chromium.launch();
      case 'firefox':
        return await firefox.launch();
      case 'webkit':
        return await webkit.launch();
    }
  }

  async testBrowserFeatures(page) {
    const results = {};

    // 测试页面加载
    await page.goto('http://localhost:3000');
    results.pageLoad = await page.evaluate(() =>
      document.readyState === 'complete'
    );

    // 测试WebSocket支持
    results.webSocket = await page.evaluate(() => {
      return typeof WebSocket !== 'undefined';
    });

    // 测试localStorage支持
    results.localStorage = await page.evaluate(() => {
      try {
        localStorage.setItem('test', 'value');
        const value = localStorage.getItem('test');
        localStorage.removeItem('test');
        return value === 'value';
      } catch (e) {
        return false;
      }
    });

    // 测试Canvas支持
    results.canvas = await page.evaluate(() => {
      const canvas = document.createElement('canvas');
      return !!(canvas.getContext && canvas.getContext('2d'));
    });

    // 测试CSS Grid支持
    results.cssGrid = await page.evaluate(() => {
      return CSS.supports('display', 'grid');
    });

    // 测试ES6支持
    results.es6 = await page.evaluate(() => {
      try {
        eval('const test = () => {}; let x = 1;');
        return true;
      } catch (e) {
        return false;
      }
    });

    return results;
  }

  generateCompatibilityReport() {
    console.log('\n=== 浏览器兼容性测试报告 ===');

    const features = ['pageLoad', 'webSocket', 'localStorage', 'canvas', 'cssGrid', 'es6'];

    console.log('功能\\浏览器\t', this.browsers.join('\t'));

    for (const feature of features) {
      const row = [feature];
      for (const browser of this.browsers) {
        const result = this.testResults[browser];
        if (result.error) {
          row.push('ERROR');
        } else {
          row.push(result[feature] ? '✓' : '✗');
        }
      }
      console.log(row.join('\t\t'));
    }
  }
}

// 运行测试
const test = new BrowserCompatibilityTest();
test.runTest();
```

### 2. 操作系统兼容性测试
```bash
#!/bin/bash
# tests/compatibility/os-compatibility.sh

# 操作系统兼容性测试脚本

echo "=== 操作系统兼容性测试 ==="

# 检测操作系统
OS=$(uname -s)
ARCH=$(uname -m)
echo "操作系统: $OS"
echo "架构: $ARCH"

# 测试Docker环境
test_docker() {
    echo "测试Docker环境..."
    if command -v docker &> /dev/null; then
        docker --version
        docker-compose --version
        echo "✓ Docker环境正常"
        return 0
    else
        echo "✗ Docker未安装"
        return 1
    fi
}

# 测试网络连接
test_network() {
    echo "测试网络连接..."
    if ping -c 1 google.com &> /dev/null; then
        echo "✓ 网络连接正常"
        return 0
    else
        echo "✗ 网络连接失败"
        return 1
    fi
}

# 测试端口占用
test_ports() {
    echo "测试端口占用..."
    ports=(8080 5432 6379 3000)

    for port in "${ports[@]}"; do
        if lsof -i:$port &> /dev/null; then
            echo "✗ 端口 $port 已被占用"
            lsof -i:$port
        else
            echo "✓ 端口 $port 可用"
        fi
    done
}

# 测试系统资源
test_resources() {
    echo "测试系统资源..."

    # 内存检查
    MEMORY=$(free -m | awk 'NR==2{printf "%.1f", $2/1024}')
    echo "可用内存: ${MEMORY}GB"

    if (( $(echo "$MEMORY >= 4.0" | bc -l) )); then
        echo "✓ 内存充足"
    else
        echo "✗ 内存不足 (需要至少4GB)"
    fi

    # 磁盘空间检查
    DISK=$(df -h / | awk 'NR==2 {print $4}' | sed 's/G//')
    echo "可用磁盘: ${DISK}GB"

    if (( $(echo "$DISK >= 20" | bc -l) )); then
        echo "✓ 磁盘空间充足"
    else
        echo "✗ 磁盘空间不足 (需要至少20GB)"
    fi
}

# 特定系统测试
test_specific_os() {
    case $OS in
        "Linux")
            # 检测Linux发行版
            if [ -f /etc/os-release ]; then
                DISTRO=$(grep '^NAME=' /etc/os-release | cut -d'"' -f2)
                echo "Linux发行版: $DISTRO"

                # 信创系统特殊处理
                if [[ $DISTRO == *"Kylin"* ]] || [[ $DISTRO == *"UOS"* ]]; then
                    echo "检测到信创系统，使用国产化配置"
                    test_xinchang_compatibility
                fi
            fi
            ;;
        "Darwin")
            echo "macOS系统"
            SW_VERS=$(sw_vers -productVersion)
            echo "系统版本: $SW_VERS"
            ;;
        *)
            echo "未知操作系统: $OS"
            ;;
    esac
}

# 信创兼容性测试
test_xinchang_compatibility() {
    echo "测试信创兼容性..."

    # 检查国产数据库支持
    if command -v dm_svc &> /dev/null; then
        echo "✓ 检测到达梦数据库"
    fi

    if command -v kingbase &> /dev/null; then
        echo "✓ 检测到人大金仓数据库"
    fi

    # 检查中间件
    if [ -d "/opt/tongweb" ]; then
        echo "✓ 检测到东方通TongWeb"
    fi
}

# 运行所有测试
main() {
    test_docker
    test_network
    test_ports
    test_resources
    test_specific_os

    echo "=== 兼容性测试完成 ==="
}

main
```

## 用户培训

### 1. 培训教程编写
```markdown
# 环境数据平台用户手册

## 1. 系统概述

环境数据平台是一个综合性的环境监测数据管理系统，提供数据采集、实时监控、分析预测和告警管理等功能。

### 1.1 主要功能
- **实时监控**: 查看传感器实时数据和环境质量状况
- **历史分析**: 分析历史数据趋势和模式
- **智能告警**: 自动监测异常情况并及时告警
- **数据管理**: 管理传感器和数据配置
- **报告生成**: 生成环境质量报告

## 2. 系统登录

### 2.1 访问系统
打开浏览器，访问: `https://env-platform.yourdomain.com`

### 2.2 登录账户
1. 输入用户名和密码
2. 点击"登录"按钮
3. 首次登录需要修改默认密码

## 3. 功能操作指南

### 3.1 数据概览
登录后默认进入数据概览页面，显示:
- 传感器在线状态统计
- 当前环境质量指标
- 最新告警信息
- 数据质量评估

### 3.2 实时监控
点击"实时监控"菜单:

#### 查看传感器状态
1. 左侧显示所有传感器列表
2. 绿色表示在线，红色表示离线
3. 点击传感器查看详细数据

#### 实时数据图表
- 数据每秒自动更新
- 可切换不同时间范围
- 支持多指标同时显示

### 3.3 历史数据分析
点击"数据分析"菜单:

#### 设置分析参数
1. 选择时间范围
2. 选择传感器
3. 选择分析指标
4. 选择分析类型

#### 查看分析结果
- 趋势分析：显示数据变化趋势
- 关联分析：分析指标间相关性
- 异常检测：识别异常数据点

### 3.4 告警管理
点击"告警管理"菜单:

#### 查看告警列表
- 按优先级排序显示
- 不同颜色表示不同严重程度
- 点击查看告警详情

#### 处理告警
1. 点击"确认"按钮确认告警
2. 填写处理备注
3. 严重告警需要上级确认

### 3.5 系统设置
管理员可访问"系统设置":

#### 传感器管理
- 添加新传感器
- 修改传感器配置
- 查看传感器状态

#### 用户管理
- 添加用户账户
- 分配用户权限
- 重置用户密码

## 4. 移动端使用
系统支持手机浏览器访问:
- 响应式设计，适配小屏幕
- 触摸操作友好
- 支持告警推送

## 5. 故障排除

### 5.1 常见问题
**问题**: 页面加载缓慢
**解决**: 检查网络连接，清除浏览器缓存

**问题**: 实时数据不更新
**解决**: 刷新页面，检查传感器连接状态

**问题**: 无法登录
**解决**: 确认用户名密码正确，联系管理员

### 5.2 技术支持
- 技术支持电话: 400-xxx-xxxx
- 邮箱: support@env-platform.com
- 在线客服: 工作日9:00-18:00
```

### 2. 培训视频制作
```python
# scripts/generate-training-videos.py
"""
培训视频制作脚本
使用Selenium自动化录制操作演示
"""

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import time
import os

class TrainingVideoGenerator:
    def __init__(self):
        self.driver = None
        self.wait = None

    def setup_driver(self):
        """初始化浏览器驱动"""
        options = webdriver.ChromeOptions()
        options.add_argument('--window-size=1920,1080')
        options.add_argument('--start-maximized')

        self.driver = webdriver.Chrome(options=options)
        self.wait = WebDriverWait(self.driver, 10)

    def start_recording(self, filename):
        """开始屏幕录制"""
        # 使用ffmpeg录制屏幕
        cmd = f"ffmpeg -f x11grab -s 1920x1080 -r 30 -i :0.0 -c:v libx264 -preset fast {filename}"
        os.system(f"{cmd} &")
        time.sleep(2)  # 等待录制开始

    def stop_recording(self):
        """停止录制"""
        os.system("pkill ffmpeg")

    def demo_login(self):
        """演示登录流程"""
        print("录制登录演示...")
        self.start_recording("login_demo.mp4")

        # 访问登录页面
        self.driver.get("http://localhost:3000/login")
        time.sleep(2)

        # 输入用户名
        username_input = self.wait.until(
            EC.presence_of_element_located((By.NAME, "username"))
        )
        username_input.send_keys("admin")
        time.sleep(1)

        # 输入密码
        password_input = self.driver.find_element(By.NAME, "password")
        password_input.send_keys("password")
        time.sleep(1)

        # 点击登录
        login_button = self.driver.find_element(By.XPATH, "//button[@type='submit']")
        login_button.click()
        time.sleep(3)

        self.stop_recording()
        print("登录演示录制完成")

    def demo_dashboard(self):
        """演示仪表板功能"""
        print("录制仪表板演示...")
        self.start_recording("dashboard_demo.mp4")

        # 浏览仪表板各个组件
        time.sleep(2)

        # 鼠标悬停在统计卡片上
        stats_cards = self.driver.find_elements(By.CLASS_NAME, "stat-card")
        for card in stats_cards:
            self.driver.execute_script("arguments[0].scrollIntoView();", card)
            time.sleep(1)

        # 查看图表
        chart_elements = self.driver.find_elements(By.CLASS_NAME, "chart-container")
        for chart in chart_elements:
            self.driver.execute_script("arguments[0].scrollIntoView();", chart)
            time.sleep(2)

        self.stop_recording()
        print("仪表板演示录制完成")

    def demo_realtime_monitoring(self):
        """演示实时监控功能"""
        print("录制实时监控演示...")
        self.start_recording("realtime_demo.mp4")

        # 导航到实时监控页面
        realtime_link = self.driver.find_element(By.LINK_TEXT, "实时监控")
        realtime_link.click()
        time.sleep(3)

        # 选择传感器
        sensor_items = self.driver.find_elements(By.CLASS_NAME, "sensor-item")
        if sensor_items:
            sensor_items[0].click()
            time.sleep(2)

        # 演示时间范围切换
        time_range_buttons = self.driver.find_elements(By.CLASS_NAME, "time-range-btn")
        for button in time_range_buttons:
            button.click()
            time.sleep(2)

        self.stop_recording()
        print("实时监控演示录制完成")

    def generate_all_demos(self):
        """生成所有演示视频"""
        self.setup_driver()

        try:
            self.demo_login()
            self.demo_dashboard()
            self.demo_realtime_monitoring()

        finally:
            self.driver.quit()

        print("所有培训视频生成完成")

if __name__ == "__main__":
    generator = TrainingVideoGenerator()
    generator.generate_all_demos()
```

## 实施计划

### 第1天: 测试环境准备
- [ ] 搭建测试环境
- [ ] 准备测试数据
- [ ] 配置测试工具

### 第2-3天: 功能测试
- [ ] API接口测试
- [ ] 前端功能测试
- [ ] 集成测试执行

### 第4-5天: 性能测试
- [ ] 负载测试
- [ ] 压力测试
- [ ] WebSocket性能测试

### 第6天: 兼容性测试
- [ ] 浏览器兼容性测试
- [ ] 操作系统兼容性测试
- [ ] 信创环境测试

### 第7天: 用户培训
- [ ] 培训资料编写
- [ ] 培训视频录制
- [ ] 用户培训实施

### 第8天: 验收交付
- [ ] 测试报告整理
- [ ] 问题修复验证
- [ ] 最终验收交付

## 交付物
- [ ] 完整测试报告
- [ ] 性能基准测试结果
- [ ] 用户培训资料和视频
- [ ] 系统运维文档

## 验收标准
- 功能测试通过率100%
- 性能指标满足SLA要求
- 兼容性测试通过主流环境
- 用户培训满意度90%以上