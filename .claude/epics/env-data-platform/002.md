---
name: 用户认证系统
status: open
created: 2025-09-16T08:20:41Z
updated: 2025-09-16T08:20:41Z
github: [Will be updated when synced to GitHub]
depends_on: [001]
parallel: true
conflicts_with: []
---

# Task 002: 用户认证系统

## 概述
实现完整的用户认证和授权系统，包括JWT登录认证、基于角色的权限管理(RBAC)以及SSO单点登录集成，为环保数据平台提供安全可靠的用户管理功能。

## 技术要求
- **认证框架**: Spring Security 6.x
- **Token管理**: JWT (JSON Web Token)
- **密码加密**: BCrypt
- **SSO协议**: SAML 2.0 / OAuth 2.0
- **缓存**: Redis (存储会话和权限信息)

## 验收标准

### 1. 用户认证功能
- [ ] 实现用户注册功能
  - 邮箱验证
  - 密码强度校验
  - 防重复注册
- [ ] 实现用户登录功能
  - 用户名/邮箱登录
  - 密码验证
  - 登录失败锁定机制
- [ ] 实现JWT令牌管理
  - Token生成和验证
  - Token刷新机制
  - Token黑名单管理

### 2. 权限管理系统
- [ ] 实现基于角色的访问控制(RBAC)
  - 角色定义和管理
  - 权限分配和继承
  - 动态权限检查
- [ ] 实现资源级权限控制
  - API接口权限
  - 数据访问权限
  - 功能模块权限
- [ ] 实现权限缓存机制
  - Redis缓存用户权限
  - 权限变更实时更新

### 3. SSO单点登录
- [ ] 集成SAML 2.0协议
  - IdP(身份提供商)配置
  - SP(服务提供商)实现
  - 元数据交换
- [ ] 集成OAuth 2.0协议
  - 授权码流程
  - 第三方平台集成(微信、企业微信等)
  - 用户信息同步

### 4. 安全增强功能
- [ ] 实现账户安全策略
  - 密码过期策略
  - 多次登录失败锁定
  - 异常登录检测
- [ ] 实现审计日志
  - 登录行为记录
  - 权限变更记录
  - 敏感操作审计

## 技术实现细节

### 数据库表结构
```sql
-- 角色表
CREATE TABLE roles (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,
    description VARCHAR(200),
    status INTEGER DEFAULT 1,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 权限表
CREATE TABLE permissions (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL,
    resource VARCHAR(100) NOT NULL,
    action VARCHAR(50) NOT NULL,
    description VARCHAR(200),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 用户角色关联表
CREATE TABLE user_roles (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT REFERENCES users(id) ON DELETE CASCADE,
    role_id BIGINT REFERENCES roles(id) ON DELETE CASCADE,
    assigned_by BIGINT REFERENCES users(id),
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user_id, role_id)
);

-- 角色权限关联表
CREATE TABLE role_permissions (
    id BIGSERIAL PRIMARY KEY,
    role_id BIGINT REFERENCES roles(id) ON DELETE CASCADE,
    permission_id BIGINT REFERENCES permissions(id) ON DELETE CASCADE,
    UNIQUE(role_id, permission_id)
);

-- 用户登录记录表
CREATE TABLE user_login_logs (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT REFERENCES users(id),
    login_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ip_address INET,
    user_agent VARCHAR(500),
    login_result VARCHAR(20), -- SUCCESS, FAILED, LOCKED
    failure_reason VARCHAR(100)
);

-- JWT黑名单表
CREATE TABLE jwt_blacklist (
    id BIGSERIAL PRIMARY KEY,
    token_id VARCHAR(100) UNIQUE NOT NULL,
    user_id BIGINT REFERENCES users(id),
    expired_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Spring Security配置
```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
public class SecurityConfig {

    @Autowired
    private JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;

    @Autowired
    private JwtRequestFilter jwtRequestFilter;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(authz -> authz
                        .requestMatchers("/api/auth/**").permitAll()
                        .requestMatchers("/api/public/**").permitAll()
                        .requestMatchers(HttpMethod.GET, "/api/data/**").hasRole("USER")
                        .requestMatchers(HttpMethod.POST, "/api/data/**").hasRole("ADMIN")
                        .anyRequest().authenticated()
                )
                .exceptionHandling(ex -> ex
                        .authenticationEntryPoint(jwtAuthenticationEntryPoint)
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                );

        http.addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class);
        return http.build();
    }
}
```

### JWT工具类
```java
@Component
public class JwtTokenUtil {

    private String secret = "${jwt.secret}";
    private int jwtExpiration = 86400; // 24小时

    public String generateToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("authorities", userDetails.getAuthorities());
        return createToken(claims, userDetails.getUsername());
    }

    public Boolean validateToken(String token, UserDetails userDetails) {
        final String username = getUsernameFromToken(token);
        return (username.equals(userDetails.getUsername())
                && !isTokenExpired(token)
                && !isTokenBlacklisted(token));
    }

    private Boolean isTokenBlacklisted(String token) {
        String jti = getClaimFromToken(token, claims -> claims.get("jti", String.class));
        return jwtBlacklistService.isBlacklisted(jti);
    }
}
```

### 权限检查注解
```java
@PreAuthorize("hasPermission(#dataSourceId, 'DataSource', 'READ')")
public DataSource getDataSource(Long dataSourceId) {
    return dataSourceService.findById(dataSourceId);
}

@PreAuthorize("hasRole('ADMIN') or @dataSourceService.isOwner(#dataSourceId, authentication.name)")
public void deleteDataSource(Long dataSourceId) {
    dataSourceService.delete(dataSourceId);
}
```

### SSO配置示例
```yaml
# SAML配置
spring:
  security:
    saml2:
      relyingparty:
        registration:
          company-idp:
            entity-id: "urn:example:company:idp"
            acs-url: "https://api.env-platform.com/saml/acs"
            metadata-uri: "https://idp.company.com/metadata"

# OAuth 2.0配置
spring:
  security:
    oauth2:
      client:
        registration:
          wechat:
            client-id: ${WECHAT_APP_ID}
            client-secret: ${WECHAT_APP_SECRET}
            scope: snsapi_userinfo
            authorization-grant-type: authorization_code
        provider:
          wechat:
            authorization-uri: https://open.weixin.qq.com/connect/oauth2/authorize
            token-uri: https://api.weixin.qq.com/sns/oauth2/access_token
            user-info-uri: https://api.weixin.qq.com/sns/userinfo
```

## API接口设计

### 认证相关接口
```
POST /api/auth/register - 用户注册
POST /api/auth/login - 用户登录
POST /api/auth/refresh - 刷新Token
POST /api/auth/logout - 用户登出
GET  /api/auth/profile - 获取用户信息
PUT  /api/auth/profile - 更新用户信息
POST /api/auth/change-password - 修改密码
```

### 权限管理接口
```
GET  /api/roles - 获取角色列表
POST /api/roles - 创建角色
GET  /api/permissions - 获取权限列表
POST /api/users/{id}/roles - 分配用户角色
GET  /api/users/{id}/permissions - 获取用户权限
```

## Definition of Done
- [ ] 用户注册、登录、登出功能完全实现并测试通过
- [ ] JWT认证机制实现，包括生成、验证、刷新和黑名单
- [ ] RBAC权限系统实现，支持角色和权限的灵活配置
- [ ] SSO单点登录集成完成，至少支持一种协议(SAML或OAuth)
- [ ] 安全策略实现，包括密码策略、登录锁定、异常检测
- [ ] 所有认证相关API接口开发完成并通过测试
- [ ] 权限控制在Controller和Service层正确实现
- [ ] 审计日志功能完整，记录关键安全事件
- [ ] 性能测试通过，认证响应时间<200ms
- [ ] 安全测试通过，无SQL注入、XSS等安全漏洞

## 风险和依赖
- **技术风险**: SSO集成可能因为第三方系统配置复杂度较高
- **安全风险**: 需要确保JWT密钥和敏感配置的安全存储
- **依赖**: 依赖Task 001的数据库表结构和基础配置

## 验证方式
- 使用Postman或类似工具测试所有认证API
- 模拟不同角色用户测试权限控制
- 集成测试验证SSO登录流程
- 安全扫描工具检测潜在漏洞
- 并发测试验证认证系统性能